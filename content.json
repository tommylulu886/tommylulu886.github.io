{"pages":[],"posts":[{"title":"PicGo + Github 打造快速上傳到圖床的工作流","text":"What PicGO ?PicGo 是一個快速上傳圖片到圖床的工具，支援多個常見圖床，能夠非常方便的將圖片上傳到圖床，其中還支援 Github 當圖床，好處是可以避免有天圖床掛掉導致圖片全部遺失，透過 PicGo + Github 就變成一個寫 Blog 苦主的神器拉，且 PicGo 是一個 Github 上的開源專案使用上完全免費，目前也支持多系統 MAC 、 Windows 、 Linux Github Project Link 目前剛結束 beta 版本測試，進入到了正式版 PicGo 設定教學使用 PicGo 快速上傳到擔任 Blog 圖床的 Github repo 登入 Github 帳號 新增一個 repository 設定為 Public repo 進入 Settings 新增一個 Personal Access Tokens 將 Access Token 複製起來貼到 PicGO 的 Github 設定頁面中的 “設定 Token” ⚠️ 創建完只會顯示出來一次，務必複製起來 ! 也請勿將 Token 洩漏給別人 ! 設定 PicGO 的 Github 紅色星號為必填參數，都可以在 Github repo 中取得相關資訊 設定快速上傳的快捷鍵這個快速上傳的功用就是，可以將剪貼簿中的圖片直接上傳到圖床 移動到 PicGo 設定 → 修改快捷鍵 將快捷鍵設定成自己順手的按鍵組合 建議可以先在常用的撰寫程式上面先測試，避免與其他功能快捷衝突 Tommy 的使用心得分享為了避免在撰寫文章的過程中，切換太多工具(截圖、Blog、撰寫素材、圖床) 造成撰寫效率下降，所以我的自己的做法是用 Snipaste 來截圖且複製到剪貼簿中，然後用 PicGo 快捷上傳到 Github，然後 PicGo 會在上傳完成後馬上將 URL or Markdown 語法 (可選) 複製到剪貼簿中，所以我可以直接貼到 Blog 編輯器上 所以流程上是三步就可以搞定一張圖片 按 F1 進入 Snipaste 截圖模式，框出想要的圖片後按 Crtl + C 儲存到剪貼簿 按 Crtl + Alt + P 讓 PicGo 快速上傳到 Github 圖床，上傳成功後會自動複製 URL 貼到 Blog 編輯器中 Reference 官網 PicGo Github project GitHub - Molunerfinn/PicGo: A simple &amp; beautiful tool for pictures uploading built by vue-cli-electron-builder 官網文件 配置手册 | PicGo","link":"/2021/11/06/PicGo-%E5%9C%96%E5%BA%8A%E5%A5%BD%E6%9C%8B%E5%8F%8B/"},{"title":"LeetCode - 941. Valid Mountain Array","text":"DifficultyEasy DescriptionGiven an array of integers arr, return true if and only if it is a valid mountain array. Recall that arr is a mountain array if and only if: arr.length &gt;= 3 There exists some i with 0 &lt; i &lt; arr.length - 1 such that: arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1] Example 1:Input: arr = [2,1] Output: false Example 2:Input: arr = [3,5,5] Output: false Example 3:Input: arr = [0,3,2,1] Output: true Constraints: 1 &lt;= arr.length &lt;= 10^4 0 &lt;= arr[i] &lt;= 10^4 Solution 1 (Python3):解法思路Line 13-16: 遍歷整個 array 然後找到最高的山峰(top)的 position 和 valueLine 18-19: 當山峰位於邊界時，代表這個 array 沒有山形，直接退出Line 24-44: 當找到山峰後，分別從左右兩側順著找下去，分別判斷是否為遞減，當一側找完時，會等待另一側完成，黨兩邊都找到底後都皆為遞減，則回傳 True Big-OTime Complexity : O(N)Space Complexity: O(1) Codeclass Solution: def validMountainArray(self, arr: List[int]) -&gt; bool: # Edge Case - 少於 3 個元素的 array if len(arr) &lt; 3: return False arr_len = len(arr) - 1 top = 0 top_index = None l_finished = False r_finished = False #線性排序找出 Peak 的 Value, Index for i in range(arr_len + 1): if arr[i] &gt; top: top_index = i top = arr[i] # Edge Case - Boundary Value 去除沒有坡度的 test case if top_index == arr_len or top_index == 0: return False l_posi = top_index r_posi = top_index # 從 peak 往兩個方向判斷是否遞減，當兩個方向都搜尋完畢則為 True while not r_finished or not l_finished: if l_finished == True: pass elif arr[l_posi] &gt; arr[l_posi - 1]: if l_posi - 1 == 0: l_finished = True else: l_posi -= 1 elif arr[l_posi] &lt;= arr[l_posi - 1]: return False if r_finished == True: pass elif arr[r_posi] &gt; arr[r_posi + 1]: if r_posi + 1 == arr_len: r_finished = True else: r_posi += 1 elif arr[r_posi] &lt;= arr[r_posi + 1]: return False return True Referencehttps://leetcode.com/problems/valid-mountain-array/","link":"/2021/12/05/LeetCode-Valid-Mountain-Array/"},{"title":"LeetCode - 283. Move Zeroes","text":"DifficultyEasy DescriptionGiven an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1:Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2:Input: nums = [0] Output: [0] Constraints: 1 &lt;= nums.length &lt;= 10^4 -2^31 &lt;= nums[i] &lt;= 2^31 - 1 Follow upFollow up : Could you minimize the total number of operations done? Solution 1 (Python3):解法思路 使用兩個 Pointer 去處理 array，宣告 final_position 用來表示已經處理完畢的位置 找到的元素不等於 0 時，代表不需要移除 如果 final_position != i, 代表前面有 0, 就將 element 與 0 的位置互換 如果 final_position == i, 代表前面沒有 0 了，直接將 element 放在原地 找到為元素等於 0 時，就不做任何動作直接 by pass Big-OTime Complexity : O(N) Space Complexity: O(1) Codeclass Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; final_position = 0 if len(nums) == 1: return nums for i in range(len(nums)): if nums[i] != 0: if final_position != i: nums[final_position], nums[i] = nums[i], 0 final_position += 1 return nums Referencehttps://leetcode.com/problems/move-zeroes/","link":"/2021/12/08/test/"}],"tags":[],"categories":[]}